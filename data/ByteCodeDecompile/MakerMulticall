#
#  Panoramix v4 Oct 2019 
#  Decompiled source of 0x5e227AD1969Ea493B43F840cfF78d08a6fc17796
# 
#  Let's make the world open source 
# 

const unknown0f28c97d = block.timestamp
const unknown27e86d6e = block.hash(block.number - 1)
const unknown72425d9d = block.difficulty
const unknown86d516e8 = block.gas_limit
const unknowna8b0574e = addr(block.coinbase)

#
#  Regular functions
#

def _fallback() payable: # default function
  revert

def getBlockHash(uint256 _i) payable: 
  require calldata.size - 4 >=′ 32
  require _i == _i
  return block.hash(_i)

def getEthBalance(address _addr) payable: 
  require calldata.size - 4 >=′ 32
  require _addr == _addr
  return eth.balance(_addr)

def unknown252dba42() payable: 
  require calldata.size - 4 >=′ 32
  require cd <= 18446744073709551615
  require cd <′ calldata.size
  require ('cd', 4).length <= 18446744073709551615
  require (32 * ('cd', 4).length) + 128 <= 18446744073709551615 and (32 * ('cd', 4).length) + 128 >= 96
  mem[64] = (32 * ('cd', 4).length) + 128
  mem[96] = ('cd', 4).length
  idx = 0
  s = cd[4] + 36
  t = 128
  while idx < ('cd', 4).length:
      require calldata.size + -cds] - 36 >=′ 64
      _56 = mem[64]
      require mem[64] + 64 <= 18446744073709551615 and mem[64] + 64 >= mem[64]
      mem[64] = mem[64] + 64
      require cd[(cds] + 36)] == addr(cd[(cds] + 36)])
      mem[_56] = cd[(cds] + 36)]
      require cd[(cds] + 68)] <= 18446744073709551615
      require cds] + cd[(cds] + 68)] + 67 <′ calldata.size
      require cd[(cds] + cd[(cds] + 68)] + 36)] <= 18446744073709551615
      _83 = mem[64]
      require mem[64] + ceil32(cd[(cds] + cd[(cds] + 68)] + 36)]) + 32 <= 18446744073709551615 and mem[64] + ceil32(cd[(cds] + cd[(cds] + 68)] + 36)]) + 32 >= mem[64]
      mem[64] = mem[64] + ceil32(cd[(cds] + cd[(cds] + 68)] + 36)]) + 32
      mem[_83] = cd[(cds] + cd[(cds] + 68)] + 36)]
      require cds] + cd[(cds] + 68)] + cd[(cds] + cd[(cds] + 68)] + 36)] + 68 <= calldata.size
      mem[_83 + 32 len cd[(cds] + cd[(cds] + 68)] + 36)]] = call.data[cds] + cd[(cds] + 68)] + 68 len cd[(cds] + cd[(cds] + 68)] + 36)]]
      mem[_83 + cd[(cds] + cd[(cds] + 68)] + 36)] + 32] = 0
      mem[_56 + 32] = _83
      mem[t] = _56
      idx = idx + 1
      s = s + 32
      t = t + 32
      continue 
  _54 = mem[96]
  _55 = mem[64]
  mem[mem[64]] = mem[96]
  mem[64] = mem[64] + (32 * _54) + 32
  if not _54:
      _106 = mem[96]
      idx = 0
      while idx < _106:
          require idx < mem[96]
          _110 = mem[mem[(32 * idx) + 128]]
          require idx < mem[96]
          _113 = mem[mem[(32 * idx) + 128] + 32]
          _114 = mem[64]
          _121 = mem[mem[mem[(32 * idx) + 128] + 32]]
          s = 0
          while s < _121:
              mem[_114 + s] = mem[_113 + s + 32]
              _106 = mem[96]
              s = s + 32
              continue 
          if ceil32(_121) <= _121:
              call addr(_110).mem[mem[64] len 4] with:
                   gas gas_remaining wei
                  args mem[mem[64] + 4 len _114 + _121 + -mem[64] - 4]
              if not return_data.size:
                  require ext_call.success
                  require idx < mem[_55]
                  mem[(32 * idx) + _55 + 32] = 96
              else:
                  _168 = mem[64]
                  mem[64] = mem[64] + ceil32(return_data.size) + 1
                  mem[_168] = return_data.size
                  mem[_168 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                  require ext_call.success
                  require idx < mem[_55]
                  mem[(32 * idx) + _55 + 32] = _168
          else:
              mem[_114 + _121] = 0
              call addr(_110).mem[mem[64] len 4] with:
                   gas gas_remaining wei
                  args mem[mem[64] + 4 len _114 + _121 + -mem[64] - 4]
              if not return_data.size:
                  require ext_call.success
                  require idx < mem[_55]
                  mem[(32 * idx) + _55 + 32] = 96
              else:
                  _171 = mem[64]
                  mem[64] = mem[64] + ceil32(return_data.size) + 1
                  mem[_171] = return_data.size
                  mem[_171 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                  require ext_call.success
                  require idx < mem[_55]
                  mem[(32 * idx) + _55 + 32] = _171
          _106 = mem[96]
          idx = idx + 1
          continue 
      _108 = mem[64]
      mem[mem[64]] = block.number
      mem[mem[64] + 32] = 64
      _125 = mem[_55]
      mem[mem[64] + 64] = mem[_55]
      idx = 0
      s = _55 + 32
      t = mem[64] + (32 * _125) + 96
      u = mem[64] + 96
      while idx < _125:
          mem[u] = t + -_108 - 96
          _155 = mem[s]
          _166 = mem[mem[s]]
          mem[t] = mem[mem[s]]
          v = 0
          while v < _166:
              mem[t + v + 32] = mem[_155 + v + 32]
              v = v + 32
              continue 
          if ceil32(_166) > _166:
              mem[t + _166 + 32] = 0
          idx = idx + 1
          s = s + 32
          t = t + ceil32(_166) + 32
          u = u + 32
          continue 
  else:
      mem[_55 + 32] = 96
      s = _55 + 32
      idx = _54
      while idx - 1:
          mem[s + 32] = 96
          s = s + 32
          idx = idx - 1
          continue 
      _154 = mem[96]
      idx = 0
      while idx < _154:
          require idx < mem[96]
          _160 = mem[mem[(32 * idx) + 128]]
          require idx < mem[96]
          _164 = mem[mem[(32 * idx) + 128] + 32]
          _165 = mem[64]
          _170 = mem[mem[mem[(32 * idx) + 128] + 32]]
          s = 0
          while s < _170:
              mem[_165 + s] = mem[_164 + s + 32]
              _154 = mem[96]
              s = s + 32
              continue 
          if ceil32(_170) <= _170:
              call addr(_160).mem[mem[64] len 4] with:
                   gas gas_remaining wei
                  args mem[mem[64] + 4 len _165 + _170 + -mem[64] - 4]
              if not return_data.size:
                  require ext_call.success
                  require idx < mem[_55]
                  mem[(32 * idx) + _55 + 32] = 96
              else:
                  _197 = mem[64]
                  mem[64] = mem[64] + ceil32(return_data.size) + 1
                  mem[_197] = return_data.size
                  mem[_197 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                  require ext_call.success
                  require idx < mem[_55]
                  mem[(32 * idx) + _55 + 32] = _197
          else:
              mem[_165 + _170] = 0
              call addr(_160).mem[mem[64] len 4] with:
                   gas gas_remaining wei
                  args mem[mem[64] + 4 len _165 + _170 + -mem[64] - 4]
              if not return_data.size:
                  require ext_call.success
                  require idx < mem[_55]
                  mem[(32 * idx) + _55 + 32] = 96
              else:
                  _199 = mem[64]
                  mem[64] = mem[64] + ceil32(return_data.size) + 1
                  mem[_199] = return_data.size
                  mem[_199 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                  require ext_call.success
                  require idx < mem[_55]
                  mem[(32 * idx) + _55 + 32] = _199
          _154 = mem[96]
          idx = idx + 1
          continue 
      _158 = mem[64]
      mem[mem[64]] = block.number
      mem[mem[64] + 32] = 64
      _176 = mem[_55]
      mem[mem[64] + 64] = mem[_55]
      idx = 0
      s = _55 + 32
      t = mem[64] + (32 * _176) + 96
      u = mem[64] + 96
      while idx < _176:
          mem[u] = t + -_158 - 96
          _192 = mem[s]
          _195 = mem[mem[s]]
          mem[t] = mem[mem[s]]
          v = 0
          while v < _195:
              mem[t + v + 32] = mem[_192 + v + 32]
              v = v + 32
              continue 
          if ceil32(_195) > _195:
              mem[t + _195 + 32] = 0
          idx = idx + 1
          s = s + 32
          t = t + ceil32(_195) + 32
          u = u + 32
          continue 
  return memory
    from mem[64]
     len t - mem[64]

